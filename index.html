<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hand Game - Lightweight Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        video { display: none; }
        #audio-guide {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.8); color: white; padding: 8px 16px;
            border-radius: 20px; font-size: 14px; z-index: 100; pointer-events: none;
            display: none; white-space: nowrap;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="audio-guide">画面をタップして音を有効にしてください</div>
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { alpha: false }); // パフォーマンス向上のためalpha無効
    const audioGuide = document.getElementById('audio-guide');

    let score = 0;
    let gameStarted = false;
    let cameraReady = false; 
    let startTime = 0;
    let nextStartEnabledTime = 0;
    const gameDuration = 40;
    
    let circleRadius, fontSizeInsideCircle, uiBoxWidth, uiBoxHeight, uiMargin;
    let circles = [];
    let targetCount = 1;

    // ポーズの平滑化 (0.5に設定し、レスポンス速度を優先)
    let smoothedHands = [ {x: 0, y: 0, active: false}, {x: 0, y: 0, active: false} ];
    const lerpAmount = 0.5; 

    // オーディオ設定
    let audioCtx = null;
    const synth = window.speechSynthesis;

    async function unlockAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            await audioCtx.resume();
        }
        audioGuide.style.display = 'none';
    }

    window.addEventListener('touchstart', unlockAudio, { passive: true });
    window.addEventListener('mousedown', unlockAudio);

    function speak(text) {
        if (synth.speaking) synth.cancel();
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'ja-JP';
        synth.speak(utter);
    }

    function playSuccessSound() {
        if (!audioCtx || audioCtx.state !== 'running') {
            audioGuide.style.display = 'block';
            return;
        }
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = 'sine';
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.frequency.setValueAtTime(880, now);
        osc.frequency.setValueAtTime(1318.51, now + 0.07);

        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

        osc.start(now);
        osc.stop(now + 0.2);
    }

    function updateCanvasSize() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        const minDim = Math.min(canvasElement.width, canvasElement.height);
        circleRadius = minDim * 0.085; 
        fontSizeInsideCircle = Math.floor(circleRadius * 1.1);
        uiBoxWidth = Math.min(canvasElement.width * 0.4, 160);
        uiBoxHeight = 45;
        uiMargin = 15;
    }
    window.addEventListener('resize', updateCanvasSize);
    updateCanvasSize();

    function generateCircles() {
        circles = [];
        targetCount = 1;
        let nums = Array.from({length: 10}, (_, i) => i + 1).sort(() => Math.random() - 0.5);
        
        const hMargin = canvasElement.width * 0.1;
        const pWidth = canvasElement.width - (hMargin * 2);
        const rows = [canvasElement.height * 0.25, canvasElement.height * 0.45, canvasElement.height * 0.65];

        for (let i = 0; i < 10; i++) {
            let xPos, yRow;
            if (i < 3) { 
                xPos = hMargin + (i + 0.5) * (pWidth / 3); 
                yRow = rows[0]; 
            } else if (i < 7) { 
                xPos = hMargin + (i - 3 + 0.5) * (pWidth / 4); 
                yRow = rows[1]; 
            } else { 
                xPos = hMargin + (i - 7 + 0.5) * (pWidth / 3); 
                yRow = rows[2]; 
            }
            circles.push({ x: xPos, y: yRow, value: nums[i], hit: false });
        }
    }

    function onResults(results) {
        if (!cameraReady) cameraReady = true;
        const currentTime = Date.now();
        const cw = canvasElement.width;
        const ch = canvasElement.height;

        canvasCtx.save();
        // 鏡面反転と描画
        canvasCtx.translate(cw, 0);
        canvasCtx.scale(-1, 1);
        
        const videoAspect = results.image.width / results.image.height;
        const canvasAspect = cw / ch;
        let drawW, drawH, dx = 0, dy = 0;
        
        if (canvasAspect > videoAspect) {
            drawW = cw; drawH = cw / videoAspect; dy = (ch - drawH) / 2;
        } else {
            drawH = ch; drawW = ch * videoAspect; dx = (cw - drawW) / 2;
        }
        canvasCtx.drawImage(results.image, dx, dy, drawW, drawH);
        canvasCtx.restore();

        let currentHands = [];
        if (results.poseLandmarks) {
            // 19: Left Index, 20: Right Index (MediaPipeは鏡面)
            [20, 19].forEach((idx, i) => {
                const lm = results.poseLandmarks[idx];
                if (lm && lm.visibility > 0.6) {
                    const targetX = (1 - lm.x) * drawW + dx;
                    const targetY = lm.y * drawH + dy;

                    if (!smoothedHands[i].active) {
                        smoothedHands[i].x = targetX;
                        smoothedHands[i].y = targetY;
                        smoothedHands[i].active = true;
                    } else {
                        smoothedHands[i].x += (targetX - smoothedHands[i].x) * lerpAmount;
                        smoothedHands[i].y += (targetY - smoothedHands[i].y) * lerpAmount;
                    }
                    currentHands.push({ x: smoothedHands[i].x, y: smoothedHands[i].y, rawY: lm.y });
                } else {
                    smoothedHands[i].active = false;
                }
            });
        }

        let timeLeft = 0;
        if (gameStarted) {
            timeLeft = Math.max(0, gameDuration - Math.floor((currentTime - startTime) / 1000));
            if (timeLeft <= 0) {
                gameStarted = false;
                nextStartEnabledTime = currentTime + 3000;
                speak(`${score}点でした。`);
            }
        } else if (currentTime > nextStartEnabledTime) {
            if (currentHands.some(h => h.rawY < 0.2)) {
                gameStarted = true; score = 0; startTime = currentTime;
                generateCircles();
                speak("スタート");
            }
        }

        if (gameStarted) {
            let allCleared = true;
            for (let c of circles) {
                if (!c.hit) {
                    allCleared = false;
                    for (let h of currentHands) {
                        const dist = Math.hypot(h.x - c.x, h.y - c.y);
                        if (c.value === targetCount && dist < circleRadius + 25) {
                            c.hit = true; score++; targetCount++;
                            playSuccessSound(); 
                        }
                    }
                    // ターゲットの円
                    canvasCtx.beginPath();
                    canvasCtx.arc(c.x, c.y, circleRadius, 0, 6.28);
                    canvasCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                    canvasCtx.fill();
                    canvasCtx.strokeStyle = 'white';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.stroke();
                    canvasCtx.fillStyle = 'white';
                    canvasCtx.font = `bold ${fontSizeInsideCircle}px Arial`;
                    canvasCtx.textAlign = "center";
                    canvasCtx.textBaseline = "middle";
                    canvasCtx.fillText(c.value, c.x, c.y);
                } else {
                    // ヒット済みの円
                    canvasCtx.beginPath();
                    canvasCtx.arc(c.x, c.y, circleRadius * 0.8, 0, 6.28);
                    canvasCtx.fillStyle = 'rgba(0, 255, 100, 0.2)';
                    canvasCtx.fill();
                }
            }
            if (allCleared) generateCircles();
        }

        // 手のインジケーター
        currentHands.forEach(h => {
            canvasCtx.beginPath();
            canvasCtx.arc(h.x, h.y, 25, 0, 6.28);
            canvasCtx.fillStyle = 'rgba(255, 255, 0, 0.9)';
            canvasCtx.fill();
            canvasCtx.strokeStyle = 'black';
            canvasCtx.lineWidth = 2;
            canvasCtx.stroke();
        });

        drawUI(cw, ch, score, timeLeft, currentTime);
    }

    function drawUI(cw, ch, score, timeLeft, currentTime) {
        canvasCtx.font = "bold 22px Arial";
        canvasCtx.textAlign = "center";
        canvasCtx.textBaseline = "middle";

        // スコア表示
        canvasCtx.fillStyle = "rgba(0, 0, 0, 0.6)";
        canvasCtx.fillRect(uiMargin, uiMargin, uiBoxWidth, uiBoxHeight);
        canvasCtx.fillStyle = "#00FF00";
        canvasCtx.fillText(`Score: ${score}`, uiMargin + uiBoxWidth/2, uiMargin + uiBoxHeight/2);

        // タイム表示
        canvasCtx.fillStyle = "rgba(0, 0, 0, 0.6)";
        canvasCtx.fillRect(cw - uiBoxWidth - uiMargin, uiMargin, uiBoxWidth, uiBoxHeight);
        canvasCtx.fillStyle = "white";
        canvasCtx.fillText(`Time: ${timeLeft}`, cw - uiBoxWidth/2 - uiMargin, uiMargin + uiBoxHeight/2);

        if (!gameStarted) {
            canvasCtx.fillStyle = "rgba(0,0,0,0.5)";
            canvasCtx.fillRect(0, ch * 0.65, cw, ch * 0.15);
            const isWait = currentTime < nextStartEnabledTime;
            canvasCtx.fillStyle = isWait ? "#FF8800" : "#FFFF00";
            
            const msg = isWait 
                ? `準備中... ${Math.ceil((nextStartEnabledTime - currentTime)/1000)}` 
                : "両手を高く上げてスタート！";
                
            canvasCtx.font = `bold ${Math.floor(cw * 0.055)}px Arial`;
            canvasCtx.fillText(msg, cw / 2, ch * 0.725);
        }
    }

    // Poseの設定最適化
    const pose = new Pose({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` });
    pose.setOptions({
        modelComplexity: 0, // Liteモデルを使用（最重要）
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    pose.onResults(onResults);

    // カメラ解像度を下げて負荷を軽減
    const camera = new Camera(videoElement, {
        onFrame: async () => { await pose.send({image: videoElement}); },
        width: 480, height: 360
    });
    camera.start();

    (function drawLoading() {
        if (!cameraReady) {
            canvasCtx.fillStyle = "black";
            canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.fillStyle = "white";
            canvasCtx.font = "18px Arial";
            canvasCtx.textAlign = "center";
            canvasCtx.fillText("カメラ起動中...", canvasElement.width / 2, canvasElement.height / 2);
            requestAnimationFrame(drawLoading);
        }
    })();
</script>
</body>
</html>